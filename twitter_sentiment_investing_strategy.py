# -*- coding: utf-8 -*-
"""Twitter Sentiment Investing Strategy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yaaSiRhvwcrBx-bCzxSCHqgPXhYvoKKC

## Load Twitter Sentiment Data

i. Load the twitter sentiment dataset, set the index, calculat engagement ratio and filter out stocks with no significant twitter activity.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
import yfinance as yf
import os
plt.style.use('ggplot')

data_folder = '/content/sentiment_data.csv'

sentiment_df = pd.read_csv(data_folder)

sentiment_df['date'] = pd.to_datetime(sentiment_df['date'])

sentiment_df = sentiment_df.set_index(['date', 'symbol'])

sentiment_df['engagement_ratio'] = sentiment_df['twitterComments']/sentiment_df['twitterLikes']

sentiment_df = sentiment_df[(sentiment_df['twitterLikes']>20)&(sentiment_df['twitterComments']>10)]

sentiment_df

# @title twitterPosts

from matplotlib import pyplot as plt
sentiment_df['twitterPosts'].plot(kind='line', figsize=(8, 4), title='twitterPosts')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title twitterImpressions

from matplotlib import pyplot as plt
sentiment_df['twitterImpressions'].plot(kind='line', figsize=(8, 4), title='twitterImpressions')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title twitterComments vs twitterLikes

from matplotlib import pyplot as plt
sentiment_df.plot(kind='scatter', x='twitterComments', y='twitterLikes', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""## 2. Aggregate Monthly and calculate average sentiment for the month
Aggregate on a monthly level and calculate average monthly metric, for the one we choose.
"""

aggragated_df = (sentiment_df.reset_index('symbol').groupby([pd.Grouper(freq='M'), 'symbol'])
                    [['engagement_ratio']].mean())

aggragated_df['rank'] = (aggragated_df.groupby(level=0)['engagement_ratio']
                         .transform(lambda x: x.rank(ascending=False)))

aggragated_df

# @title rank

from matplotlib import pyplot as plt
aggragated_df['rank'].plot(kind='line', figsize=(8, 4), title='rank')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title engagement_ratio

from matplotlib import pyplot as plt
aggragated_df['engagement_ratio'].plot(kind='line', figsize=(8, 4), title='engagement_ratio')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title Engagement Ratio vs. Rank

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(aggragated_df['rank'], aggragated_df['engagement_ratio'], alpha=0.5)
plt.title('Engagement Ratio vs. Rank')
plt.xlabel('Rank')
_ = plt.ylabel('Engagement Ratio')

"""## 3. Select Top 5 Stocks based on their cross-sectional ranking for each month
Select top 5 stocks by rank for each month and fix the date to start at beginning of next month.
"""

filtered_df = aggragated_df[aggragated_df['rank']<6].copy()

filtered_df = filtered_df.reset_index(level=1)

filtered_df.index = filtered_df.index+pd.DateOffset(1)

filtered_df = filtered_df.reset_index().set_index(['date', 'symbol'])

filtered_df.head(20)

# @title engagement_ratio

from matplotlib import pyplot as plt
filtered_df['engagement_ratio'].plot(kind='line', figsize=(8, 4), title='engagement_ratio')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title Engagement Ratio vs. Rank

import matplotlib.pyplot as plt

# Assuming your data is in a pandas DataFrame called 'filtered_df'

plt.figure(figsize=(8, 6))
plt.scatter(filtered_df['rank'], filtered_df['engagement_ratio'])
plt.title('Engagement Ratio vs. Rank')
plt.xlabel('Rank')
_ = plt.ylabel('Engagement Ratio')

"""## 4. Extract the stocks to form portfolios with at the start of each new month
Create a dictionary containing start of month and corresponded selected stocks.
"""

dates = filtered_df.index.get_level_values('date').unique().tolist()

fixed_dates = {}

for d in dates:

    fixed_dates[d.strftime('%Y-%m-%d')] = filtered_df.xs(d, level=0).index.tolist()

fixed_dates

"""## 5. Download fresh stock prices for only selected/shortlisted stocks"""

import yfinance as yf
import pandas as pd

# Extract the list of tickers from your sentiment data
stocks_list = sentiment_df.index.get_level_values('symbol').unique().tolist()

# Try downloading data and handle any errors
valid_tickers = []
for ticker in stocks_list:
    try:
        # Attempt to download data for each ticker
        data = yf.download(ticker, start='2021-01-01', end='2023-03-01')
        if not data.empty:  # Check if the data is not empty
            valid_tickers.append(ticker)
        else:
            print(f"Ticker {ticker} returned no data.")
    except Exception as e:
        print(f"Error downloading data for ticker {ticker}: {e}")

# Now, download data for the valid tickers only
if valid_tickers:
    prices_df = yf.download(tickers=valid_tickers, start='2021-01-01', end='2023-03-01')
    print(f"Downloaded data for {len(valid_tickers)} valid tickers.")
else:
    print("No valid tickers found.")

# Check the first few rows of the downloaded data
print(prices_df.head())

"""## 6. Calculate Portfolio Returns with monthly rebalancing

"""

returns_df = np.log(prices_df['Adj Close']).diff().dropna()

portfolio_df = pd.DataFrame()

for start_date in fixed_dates.keys():

    end_date = (pd.to_datetime(start_date)+pd.offsets.MonthEnd()).strftime('%Y-%m-%d')

    cols = fixed_dates[start_date]

    temp_df = returns_df[start_date:end_date][cols].mean(axis=1).to_frame('portfolio_return')

    portfolio_df = pd.concat([portfolio_df, temp_df], axis=0)

portfolio_df

# @title nasdaq_return

from matplotlib import pyplot as plt
portfolio_df['nasdaq_return'].plot(kind='line', figsize=(8, 4), title='nasdaq_return')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title portfolio_return

from matplotlib import pyplot as plt
portfolio_df['portfolio_return'].plot(kind='line', figsize=(8, 4), title='portfolio_return')
plt.gca().spines[['top', 'right']].set_visible(False)

# @title portfolio_return vs nasdaq_return

from matplotlib import pyplot as plt
portfolio_df.plot(kind='scatter', x='portfolio_return', y='nasdaq_return', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""## 7. Download NASDAQ/QQQ prices and calculate returns to compare to our strategy

"""

import numpy as np
import yfinance as yf

# Download QQQ data
qqq_df = yf.download(tickers='QQQ', start='2021-01-01', end='2023-03-01')

# Calculate the log returns of the adjusted close prices
qqq_ret = np.log(qqq_df['Adj Close']).diff()

# Ensure qqq_ret is a Series before converting to DataFrame
# If qqq_ret is already a DataFrame
qqq_ret.columns = ['nasdaq_return']

# Merge the returns with your existing portfolio dataframe
portfolio_df = portfolio_df.merge(qqq_ret, left_index=True, right_index=True)

# Display the resulting portfolio dataframe
portfolio_df

# @title Correlation between Portfolio and Nasdaq Returns

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.scatter(portfolio_df['nasdaq_return'], portfolio_df['portfolio_return'], alpha=0.5)
plt.xlabel('Nasdaq Return')
plt.ylabel('Portfolio Return')
_ = plt.title('Correlation between Portfolio and Nasdaq Returns')

import matplotlib.ticker as mtick
import numpy as np
import matplotlib.pyplot as plt

# Assuming portfolio_df is already defined

# Calculate cumulative return
portfolios_cumulative_return = np.exp(np.log1p(portfolio_df).cumsum()).sub(1)

# Plot cumulative return
portfolios_cumulative_return.plot(figsize=(16, 6))

plt.title('Twitter Engagement Ratio Strategy Return Over Time')

# Set y-axis labels as percentage format
plt.gca().yaxis.set_major_formatter(mtick.PercentFormatter(1))

plt.ylabel('Return')
plt.show()